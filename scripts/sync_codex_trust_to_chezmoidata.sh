#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

SOURCE_CONFIG="${HOME}/.codex/config.toml"
TARGET_DATA_FILE="${REPO_ROOT}/.chezmoidata/codex.local.toml"

mkdir -p "$(dirname "${TARGET_DATA_FILE}")"

tmp_file="$(mktemp)"
trap 'rm -f "${tmp_file}"' EXIT

if [[ ! -f "${SOURCE_CONFIG}" ]]; then
  {
    echo "# Generated by scripts/sync_codex_trust_to_chezmoidata.sh"
    echo "# Source config was not found: ${SOURCE_CONFIG}"
    echo "[codex.project_trust]"
  } > "${tmp_file}"

  mv "${tmp_file}" "${TARGET_DATA_FILE}"
  echo "skipped: ${SOURCE_CONFIG} not found"
  echo "written: ${TARGET_DATA_FILE}"
  exit 0
fi

awk '
BEGIN {
  current_path = "";
  count = 0;
}

match($0, /^\[projects\."[^"]+"\]$/) {
  current_path = $0;
  sub(/^\[projects\."/,"", current_path);
  sub(/"\]$/,"", current_path);
  next;
}

match($0, /^trust_level[[:space:]]*=[[:space:]]*"(trusted|untrusted)"[[:space:]]*$/) && current_path != "" {
  level = $0;
  sub(/^trust_level[[:space:]]*=[[:space:]]*"/,"", level);
  sub(/"$/,"", level);

  if (!(current_path in seen)) {
    seen[current_path] = 1;
    order[count] = current_path;
    count++;
  }

  trust[current_path] = level;
  current_path = "";
  next;
}

END {
  print "# Generated by scripts/sync_codex_trust_to_chezmoidata.sh";
  print "# This file is machine-local and intentionally gitignored.";
  print "[codex.project_trust]";

  for (i = 0; i < count; i++) {
    path = order[i];
    level = trust[path];

    escaped = path;
    gsub(/\\/, "\\\\", escaped);
    gsub(/"/, "\\\"", escaped);

    printf "\"%s\" = \"%s\"\n", escaped, level;
  }
}
' "${SOURCE_CONFIG}" > "${tmp_file}"

mv "${tmp_file}" "${TARGET_DATA_FILE}"
echo "written: ${TARGET_DATA_FILE}"
